// Generated by CoffeeScript 1.12.7
(function() {
  var PostgresAdapter, Promise, _connect, escape, initialize, pg, pools;

  Promise = require('bluebird');

  pg = require('pg');

  Promise.promisifyAll(pg);

  escape = require('pg-escape');

  pools = {};

  _connect = (function(_this) {
    return function(config, cb) {
      var pool;
      pool = pools[config.url];
      if (pool == null) {
        pool = new pg.Pool(config);
        pools[config.url] = pool;
      }
      return pool.connect(cb);
    };
  })(this);

  PostgresAdapter = (function() {
    function PostgresAdapter(options) {
      var o, ref, ref1, ref2, ref3, ref4, ref5, ref6;
      this.options = options;
      this._dbOptions = o = {
        database: (ref = this.options.database) != null ? ref : process.env.PGDATABASE,
        host: (ref1 = (ref2 = this.options.host) != null ? ref2 : process.env.PGHOST) != null ? ref1 : 'localhost',
        port: (ref3 = (ref4 = this.options.port) != null ? ref4 : process.env.PGPORT) != null ? ref3 : '5432',
        ssl: (ref5 = this.options.ssl) != null ? ref5 : process.env.PGSSLMODE,
        user: (ref6 = this.options.user) != null ? ref6 : process.env.PGUSER
      };
      this._dbOptions.url = "postgres://" + o.user + '@' + o.host + ':' + o.port + '/' + o.database + '?ssl=' + (o.ssl || false);
      this.features = {
        xwrap: {
          basic: true,
          subtransactions: true,
          wrap: true,
          clientMethods: ['queryAsync'],
          clientDataAttributes: ['connectionParameters']
        }
      };
    }

    PostgresAdapter.prototype.close = function() {
      var xwrap;
      xwrap = require('xwrap');
      return xwrap.disconnect(this.id);
    };

    PostgresAdapter.prototype.disconnect = function() {
      var key, pool, self;
      self = this;
      key = this._dbOptions.url;
      console.log("pools", Object.keys(pools));
      pool = pools[key];
      return Promise["try"](function() {
        if (pool == null) {
          return;
        }
        if (pool.pool != null) {
          pool = pool.pool;
        }
        return new Promise(function(res) {
          return pool.drain(function() {
            return pool.destroyAllNow(function() {
              var ref;
              if ((ref = pg[poolKey]) != null) {
                delete ref[key];
              }
              return res();
            });
          });
        });
      })["finally"](function() {
        return self.close();
      });
    };

    PostgresAdapter.prototype.getRawClient = function() {
      var close, self;
      self = this;
      close = null;
      return new Promise(function(res, rej) {
        return _connect(self._dbOptions, function(err, client, done) {
          if (err != null) {
            return rej(err);
          }
          close = done;
          return res(client);
        });
      }).disposer(function() {
        if (close != null) {
          return close();
        }
      });
    };

    PostgresAdapter.prototype.getClient = function(callerName) {
      var self;
      self = this;
      return this.xtransaction.client(callerName).then(function(client) {
        return client != null ? client : self.getRawClient();
      });
    };

    PostgresAdapter.prototype.withClient = function(callerName, cb) {
      if (typeof cb !== 'function') {
        cb = callerName;
        callerName = '???';
      }
      return this.getClient(callerName).then(function(cpromise) {
        return Promise.using(cpromise, cb);
      });
    };

    PostgresAdapter.prototype.openTransaction = function(client) {
      return client.queryAsync('begin');
    };

    PostgresAdapter.prototype.commitTransaction = function(client) {
      return client.queryAsync('commit');
    };

    PostgresAdapter.prototype.rollbackTransaction = function(client) {
      return client.queryAsync('rollback');
    };

    PostgresAdapter.prototype.openSubTransaction = function(client, name) {
      return client.queryAsync("savepoint " + (escape.ident(name)));
    };

    PostgresAdapter.prototype.commitSubTransaction = function(client, name) {
      return client.queryAsync("release " + (escape.ident(name)));
    };

    PostgresAdapter.prototype.rollbackSubTransaction = function(client, name) {
      return client.queryAsync("rollback to " + (escape.ident(name)));
    };

    PostgresAdapter.prototype.wrap = function() {
      var self;
      self = this;
      return pg.connect = function(connStr, callback) {
        return self.getRawClient()["catch"](function(err) {
          callback(err, null, null);
          throw err;
        }).then(function(client) {
          return new Promise(function(res, rej) {
            return callback(null, client, function(err) {
              if (err != null) {
                return rej(err);
              }
              return res();
            });
          });
        });
      };
    };

    return PostgresAdapter;

  })();

  module.exports = initialize = function(settings) {
    return new PostgresAdapter(settings);
  };

  initialize.PostgresAdapter = PostgresAdapter;

}).call(this);
