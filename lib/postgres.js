// Generated by CoffeeScript 1.10.0
(function() {
  var PostgresAdapter, Promise, _connect, escape, initialize, pg;

  Promise = require('bluebird');

  pg = require('pg');

  Promise.promisifyAll(pg);

  escape = require('pg-escape');

  _connect = pg.connect;

  PostgresAdapter = (function() {
    function PostgresAdapter(options) {
      this.options = options;
      this.features = {
        xwrap: {
          basic: true,
          subtransactions: true,
          wrap: true,
          clientMethods: ['queryAsync'],
          clientDataAttributes: ['connectionParameters']
        }
      };
    }

    PostgresAdapter.prototype.close = function() {
      var xwrap;
      xwrap = require('xwrap');
      return xwrap.disconnect(this.id);
    };

    PostgresAdapter.prototype.disconnect = function() {
      var pool;
      pool = pg.pools.all[JSON.stringify(this.options)];
      return Promise["try"](function() {
        if (pool == null) {
          return;
        }
        return new Promise(function(res) {
          return pool.drain(function() {
            pool.destroyAllNow();
            return res();
          });
        });
      });
    };

    PostgresAdapter.prototype.getRawClient = function() {
      var close, self;
      self = this;
      close = null;
      return new Promise(function(res, rej) {
        return _connect.call(pg, self.options, function(err, client, done) {
          if (err != null) {
            return rej(err);
          }
          close = done;
          return res(client);
        });
      }).disposer(function() {
        if (close != null) {
          return close();
        }
      });
    };

    PostgresAdapter.prototype.getClient = function(callerName) {
      var self;
      self = this;
      return this.xtransaction.client(callerName).then(function(client) {
        return client != null ? client : self.getRawClient();
      });
    };

    PostgresAdapter.prototype.openTransaction = function(client) {
      return client.queryAsync('begin');
    };

    PostgresAdapter.prototype.commitTransaction = function(client) {
      return client.queryAsync('commit');
    };

    PostgresAdapter.prototype.rollbackTransaction = function(client) {
      return client.queryAsync('rollback');
    };

    PostgresAdapter.prototype.openSubTransaction = function(client, name) {
      return client.queryAsync("savepoint " + (escape.ident(name)));
    };

    PostgresAdapter.prototype.commitSubTransaction = function(client, name) {
      return client.queryAsync("release " + (escape.ident(name)));
    };

    PostgresAdapter.prototype.rollbackSubTransaction = function(client, name) {
      return client.queryAsync("rollback to " + (escape.ident(name)));
    };

    PostgresAdapter.prototype.wrap = function() {
      var self;
      self = this;
      return pg.connect = function(connStr, callback) {
        return self.getRawClient()["catch"](function(err) {
          callback(err, null, null);
          throw err;
        }).then(function(client) {
          return new Promise(function(res, rej) {
            return callback(null, client, function(err) {
              if (err != null) {
                return rej(err);
              }
              return res();
            });
          });
        });
      };
    };

    return PostgresAdapter;

  })();

  module.exports = initialize = function(settings) {
    return new PostgresAdapter(settings);
  };

  initialize.PostgresAdapter = PostgresAdapter;

}).call(this);
